{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Modify Draft/Artwork Selection to Radio Button Style",
        "description": "Change the current selection mechanism for draft/artwork from multi-select to radio button style to ensure only one option can be selected at a time.",
        "details": "1. Locate the current selection component in the codebase\n2. Replace checkbox implementation with radio button inputs\n3. Ensure the state management only allows one selection at a time\n4. Update the UI to visually indicate the radio button style selection\n5. Implement proper state handling to display the selected content\n6. Handle edge cases such as deselection and initial state\n\nExample implementation:\n```typescript\n// Component for draft/artwork selection\nimport { useState } from 'react';\n\ntype SelectionType = 'draft' | 'artwork' | null;\n\nconst ContentSelector = () => {\n  const [selected, setSelected] = useState<SelectionType>(null);\n  \n  return (\n    <div className=\"selection-container\">\n      <label className=\"radio-label\">\n        <input\n          type=\"radio\"\n          name=\"content-type\"\n          value=\"draft\"\n          checked={selected === 'draft'}\n          onChange={() => setSelected('draft')}\n          className=\"hidden\"\n        />\n        <span className=\"custom-radio\"></span>\n        Draft\n      </label>\n      \n      <label className=\"radio-label\">\n        <input\n          type=\"radio\"\n          name=\"content-type\"\n          value=\"artwork\"\n          checked={selected === 'artwork'}\n          onChange={() => setSelected('artwork')}\n          className=\"hidden\"\n        />\n        <span className=\"custom-radio\"></span>\n        Artwork\n      </label>\n      \n      {selected && (\n        <div className=\"content-display\">\n          {/* Display content based on selection */}\n          {selected === 'draft' ? <DraftContent /> : <ArtworkContent />}\n        </div>\n      )}\n    </div>\n  );\n};\n```",
        "testStrategy": "1. Unit tests to verify radio button behavior:\n   - Test that only one option can be selected at a time\n   - Test that the correct content displays based on selection\n   - Test initial state and edge cases\n2. Integration tests to ensure the selection affects the content display correctly\n3. Manual testing across different browsers to verify UI consistency\n4. Accessibility testing to ensure the radio buttons are keyboard navigable and screen reader compatible",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Improve Comparison Mode UI",
        "description": "Enhance the comparison mode to display draft and artwork side by side automatically when the mode is activated, eliminating the need for additional button clicks.",
        "details": "1. Modify the comparison mode component to automatically display both draft and artwork\n2. Implement a side-by-side layout with responsive design considerations\n3. Add visual indicators to distinguish between draft and artwork\n4. Ensure proper image scaling and alignment\n5. Add smooth transitions when entering/exiting comparison mode\n\nImplementation approach:\n```typescript\n// Comparison mode component\nimport { useEffect, useState } from 'react';\nimport Image from 'next/image';\n\ninterface ComparisonModeProps {\n  isActive: boolean;\n  draftImage: string;\n  artworkImage: string;\n}\n\nconst ComparisonMode: React.FC<ComparisonModeProps> = ({ \n  isActive, \n  draftImage, \n  artworkImage \n}) => {\n  // Only render content when comparison mode is active\n  if (!isActive) return null;\n  \n  return (\n    <div className=\"comparison-container\">\n      <div className=\"comparison-grid\">\n        <div className=\"comparison-item\">\n          <div className=\"comparison-label\">Draft</div>\n          <div className=\"image-container\">\n            <Image \n              src={draftImage} \n              alt=\"Draft version\" \n              layout=\"responsive\"\n              width={500}\n              height={300}\n              objectFit=\"contain\"\n            />\n          </div>\n        </div>\n        \n        <div className=\"comparison-item\">\n          <div className=\"comparison-label\">Artwork</div>\n          <div className=\"image-container\">\n            <Image \n              src={artworkImage} \n              alt=\"Artwork version\" \n              layout=\"responsive\"\n              width={500}\n              height={300}\n              objectFit=\"contain\"\n            />\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n```\n\nCSS with Tailwind:\n```tsx\n// Tailwind classes for the comparison mode\n<div className=\"grid grid-cols-1 md:grid-cols-2 gap-4 w-full transition-all duration-300 ease-in-out\">\n  {/* Draft side */}\n  <div className=\"border rounded-lg p-4 bg-gray-50\">\n    <h3 className=\"text-lg font-medium mb-2 text-gray-700\">Draft</h3>\n    {/* Image container */}\n  </div>\n  \n  {/* Artwork side */}\n  <div className=\"border rounded-lg p-4 bg-gray-50\">\n    <h3 className=\"text-lg font-medium mb-2 text-gray-700\">Artwork</h3>\n    {/* Image container */}\n  </div>\n</div>\n```",
        "testStrategy": "1. Unit tests for the comparison mode component:\n   - Test that both images render when comparison mode is active\n   - Test that the component doesn't render when inactive\n2. Integration tests to verify the activation/deactivation of comparison mode\n3. Responsive design testing across different screen sizes\n4. Performance testing with large images to ensure smooth loading\n5. User acceptance testing to verify the improved workflow meets expectations",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Scene Addition Functionality",
        "description": "Create a new feature allowing users to add new scenes to the storyboard, including a button to trigger the action, a modal for scene creation, and scene list management.",
        "details": "1. Add a \"New Scene\" button in the appropriate UI location\n2. Create a modal component for scene creation with form fields\n3. Implement scene list state management\n4. Add functionality to save new scenes to the backend\n5. Update the scene navigation UI to include newly added scenes\n\nImplementation details:\n```typescript\n// Scene addition button and modal\nimport { useState } from 'react';\nimport { Dialog } from '@headlessui/react';\n\ninterface Scene {\n  id: string;\n  title: string;\n  description?: string;\n  order: number;\n}\n\nconst SceneManager = () => {\n  const [scenes, setScenes] = useState<Scene[]>([]);\n  const [isModalOpen, setIsModalOpen] = useState(false);\n  const [newScene, setNewScene] = useState<Omit<Scene, 'id'>>({ \n    title: '', \n    description: '', \n    order: 0 \n  });\n  \n  const handleAddScene = async () => {\n    try {\n      // Generate a unique ID or let the backend handle it\n      const sceneId = Date.now().toString();\n      \n      // In a real app, you would make an API call here\n      // const response = await fetch('/api/scenes', {\n      //   method: 'POST',\n      //   body: JSON.stringify(newScene),\n      //   headers: { 'Content-Type': 'application/json' }\n      // });\n      // const data = await response.json();\n      \n      // For demo purposes, we'll just update the local state\n      const createdScene = {\n        ...newScene,\n        id: sceneId,\n        order: scenes.length + 1\n      };\n      \n      setScenes([...scenes, createdScene]);\n      setIsModalOpen(false);\n      setNewScene({ title: '', description: '', order: 0 });\n    } catch (error) {\n      console.error('Failed to add scene:', error);\n    }\n  };\n  \n  return (\n    <div className=\"scene-manager\">\n      <div className=\"scene-list\">\n        {scenes.map((scene) => (\n          <div key={scene.id} className=\"scene-item\">\n            <h3>{scene.title}</h3>\n            <p>{scene.description}</p>\n          </div>\n        ))}\n      </div>\n      \n      <button \n        onClick={() => setIsModalOpen(true)}\n        className=\"add-scene-button\"\n      >\n        Add New Scene\n      </button>\n      \n      <Dialog \n        open={isModalOpen} \n        onClose={() => setIsModalOpen(false)}\n        className=\"scene-modal\"\n      >\n        <Dialog.Panel>\n          <Dialog.Title>Add New Scene</Dialog.Title>\n          \n          <div className=\"form-group\">\n            <label htmlFor=\"scene-title\">Title</label>\n            <input\n              id=\"scene-title\"\n              type=\"text\"\n              value={newScene.title}\n              onChange={(e) => setNewScene({...newScene, title: e.target.value})}\n              required\n            />\n          </div>\n          \n          <div className=\"form-group\">\n            <label htmlFor=\"scene-description\">Description</label>\n            <textarea\n              id=\"scene-description\"\n              value={newScene.description}\n              onChange={(e) => setNewScene({...newScene, description: e.target.value})}\n            />\n          </div>\n          \n          <div className=\"modal-actions\">\n            <button onClick={() => setIsModalOpen(false)}>Cancel</button>\n            <button \n              onClick={handleAddScene}\n              disabled={!newScene.title}\n            >\n              Save Scene\n            </button>\n          </div>\n        </Dialog.Panel>\n      </Dialog>\n    </div>\n  );\n};\n```",
        "testStrategy": "1. Unit tests for the scene addition component:\n   - Test form validation\n   - Test modal opening/closing\n   - Test scene creation logic\n2. Integration tests for scene list management:\n   - Test adding a scene updates the scene list\n   - Test scene ordering\n3. API endpoint tests (if applicable)\n4. User flow testing to ensure the process is intuitive\n5. Accessibility testing for the modal dialog\n6. State management tests to verify scenes persist correctly",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Add Annotation Drawing Functionality",
        "description": "Implement a canvas overlay system that allows users to draw annotations on top of drafts/artwork without modifying the original images, with the ability to show/hide annotations linked to comments.",
        "details": "1. Create a canvas overlay component that sits on top of images\n2. Implement drawing tools (pen, highlighter, shapes, etc.)\n3. Store annotations as vector data separate from the image\n4. Link annotations to comments in the system\n5. Add toggle controls to show/hide annotations\n\nImplementation approach using Canvas API:\n```typescript\n// Annotation canvas component\nimport { useRef, useState, useEffect } from 'react';\n\ninterface AnnotationCanvasProps {\n  imageUrl: string;\n  commentId?: string;\n  onSave: (annotationData: string, commentId?: string) => void;\n}\n\ntype DrawingMode = 'pen' | 'highlighter' | 'rectangle' | 'arrow' | null;\n\nconst AnnotationCanvas: React.FC<AnnotationCanvasProps> = ({ \n  imageUrl, \n  commentId, \n  onSave \n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const imageRef = useRef<HTMLImageElement>(null);\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [drawingMode, setDrawingMode] = useState<DrawingMode>('pen');\n  const [color, setColor] = useState('#FF0000'); // Default red\n  const [lineWidth, setLineWidth] = useState(3);\n  const [canvasHistory, setCanvasHistory] = useState<ImageData[]>([]);\n  const [historyIndex, setHistoryIndex] = useState(-1);\n  \n  // Initialize canvas when component mounts\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const image = imageRef.current;\n    if (!canvas || !image) return;\n    \n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    \n    // Set canvas dimensions to match image\n    image.onload = () => {\n      canvas.width = image.width;\n      canvas.height = image.height;\n      \n      // Save initial blank state\n      const initialState = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      setCanvasHistory([initialState]);\n      setHistoryIndex(0);\n    };\n    \n    image.src = imageUrl;\n  }, [imageUrl]);\n  \n  // Drawing event handlers\n  const startDrawing = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    const canvas = canvasRef.current;\n    const ctx = canvas?.getContext('2d');\n    if (!canvas || !ctx || !drawingMode) return;\n    \n    setIsDrawing(true);\n    \n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    \n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.strokeStyle = color;\n    ctx.lineWidth = lineWidth;\n    ctx.lineCap = 'round';\n    \n    if (drawingMode === 'highlighter') {\n      ctx.globalAlpha = 0.3;\n    } else {\n      ctx.globalAlpha = 1.0;\n    }\n  };\n  \n  const draw = (e: React.MouseEvent<HTMLCanvasElement>) => {\n    if (!isDrawing) return;\n    \n    const canvas = canvasRef.current;\n    const ctx = canvas?.getContext('2d');\n    if (!canvas || !ctx) return;\n    \n    const rect = canvas.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    \n    ctx.lineTo(x, y);\n    ctx.stroke();\n  };\n  \n  const stopDrawing = () => {\n    const canvas = canvasRef.current;\n    const ctx = canvas?.getContext('2d');\n    if (!canvas || !ctx || !isDrawing) return;\n    \n    ctx.closePath();\n    setIsDrawing(false);\n    \n    // Save current state to history\n    const currentState = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    const newHistory = canvasHistory.slice(0, historyIndex + 1);\n    newHistory.push(currentState);\n    \n    setCanvasHistory(newHistory);\n    setHistoryIndex(newHistory.length - 1);\n  };\n  \n  const saveAnnotation = () => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    // Convert canvas to data URL\n    const annotationData = canvas.toDataURL('image/png');\n    onSave(annotationData, commentId);\n  };\n  \n  const clearCanvas = () => {\n    const canvas = canvasRef.current;\n    const ctx = canvas?.getContext('2d');\n    if (!canvas || !ctx) return;\n    \n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    \n    // Reset history\n    const blankState = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    setCanvasHistory([blankState]);\n    setHistoryIndex(0);\n  };\n  \n  return (\n    <div className=\"annotation-container\">\n      <img \n        ref={imageRef} \n        src={imageUrl} \n        alt=\"Content for annotation\" \n        className=\"annotation-image\"\n        style={{ display: 'none' }} // Hidden, used only for dimensions\n      />\n      \n      <canvas\n        ref={canvasRef}\n        className=\"annotation-canvas\"\n        onMouseDown={startDrawing}\n        onMouseMove={draw}\n        onMouseUp={stopDrawing}\n        onMouseLeave={stopDrawing}\n      />\n      \n      <div className=\"annotation-toolbar\">\n        <div className=\"tool-group\">\n          <button \n            className={`tool-button ${drawingMode === 'pen' ? 'active' : ''}`}\n            onClick={() => setDrawingMode('pen')}\n          >\n            Pen\n          </button>\n          <button \n            className={`tool-button ${drawingMode === 'highlighter' ? 'active' : ''}`}\n            onClick={() => setDrawingMode('highlighter')}\n          >\n            Highlighter\n          </button>\n          {/* Add more tools as needed */}\n        </div>\n        \n        <div className=\"color-picker\">\n          <input \n            type=\"color\" \n            value={color}\n            onChange={(e) => setColor(e.target.value)}\n          />\n        </div>\n        \n        <div className=\"action-buttons\">\n          <button onClick={clearCanvas}>Clear</button>\n          <button onClick={saveAnnotation}>Save</button>\n        </div>\n      </div>\n    </div>\n  );\n};\n```",
        "testStrategy": "1. Unit tests for the annotation canvas component:\n   - Test drawing functionality\n   - Test tool switching\n   - Test color selection\n   - Test save/clear operations\n2. Integration tests for annotation-comment linking:\n   - Test that annotations are correctly associated with comments\n   - Test show/hide functionality based on comment selection\n3. Canvas rendering tests to ensure proper overlay positioning\n4. Performance testing with complex drawings\n5. Browser compatibility testing for Canvas API support\n6. Touch device testing for mobile drawing support\n7. Data persistence testing to verify annotations save correctly",
        "priority": "medium",
        "dependencies": [
          1,
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Enhance Workflow with Status Tracking",
        "description": "Improve the workflow by adding a 'Revision Complete' button, clarifying the status transition flow, and implementing UI elements to track progress throughout the revision process.",
        "details": "1. Add a 'Revision Complete' button to the UI when in revision mode\n2. Implement state management for tracking workflow status\n3. Create visual indicators for current status\n4. Design and implement a status transition system\n5. Add confirmation dialogs for status changes\n\nImplementation approach:\n```typescript\n// Workflow status management\nimport { useState, createContext, useContext, ReactNode } from 'react';\n\ntype WorkflowStatus = 'draft' | 'review' | 'revision' | 'completed';\n\ninterface WorkflowContextType {\n  status: WorkflowStatus;\n  setStatus: (status: WorkflowStatus) => void;\n  requestRevision: () => void;\n  completeRevision: () => void;\n  approveArtwork: () => void;\n}\n\nconst WorkflowContext = createContext<WorkflowContextType | undefined>(undefined);\n\nexport const WorkflowProvider: React.FC<{children: ReactNode}> = ({ children }) => {\n  const [status, setStatus] = useState<WorkflowStatus>('draft');\n  \n  const requestRevision = async () => {\n    try {\n      // API call to update status in backend\n      // await fetch('/api/workflow/request-revision', { method: 'POST' });\n      \n      setStatus('revision');\n      // Additional logic like notifications, etc.\n    } catch (error) {\n      console.error('Failed to request revision:', error);\n    }\n  };\n  \n  const completeRevision = async () => {\n    try {\n      // API call to update status in backend\n      // await fetch('/api/workflow/complete-revision', { method: 'POST' });\n      \n      setStatus('review');\n      // Additional logic\n    } catch (error) {\n      console.error('Failed to complete revision:', error);\n    }\n  };\n  \n  const approveArtwork = async () => {\n    try {\n      // API call to update status in backend\n      // await fetch('/api/workflow/approve', { method: 'POST' });\n      \n      setStatus('completed');\n      // Additional logic\n    } catch (error) {\n      console.error('Failed to approve artwork:', error);\n    }\n  };\n  \n  return (\n    <WorkflowContext.Provider value={{\n      status,\n      setStatus,\n      requestRevision,\n      completeRevision,\n      approveArtwork\n    }}>\n      {children}\n    </WorkflowContext.Provider>\n  );\n};\n\n// Custom hook to use the workflow context\nexport const useWorkflow = () => {\n  const context = useContext(WorkflowContext);\n  if (context === undefined) {\n    throw new Error('useWorkflow must be used within a WorkflowProvider');\n  }\n  return context;\n};\n\n// Workflow status UI component\nconst WorkflowStatusBar: React.FC = () => {\n  const { status, requestRevision, completeRevision, approveArtwork } = useWorkflow();\n  \n  return (\n    <div className=\"workflow-status-bar\">\n      <div className=\"status-indicator\">\n        <div className=\"status-label\">Current Status:</div>\n        <div className={`status-value status-${status}`}>\n          {status.charAt(0).toUpperCase() + status.slice(1)}\n        </div>\n      </div>\n      \n      <div className=\"workflow-actions\">\n        {status === 'draft' && (\n          <button \n            onClick={requestRevision}\n            className=\"action-button request-revision\"\n          >\n            Request Revision\n          </button>\n        )}\n        \n        {status === 'revision' && (\n          <button \n            onClick={completeRevision}\n            className=\"action-button complete-revision\"\n          >\n            Revision Complete\n          </button>\n        )}\n        \n        {status === 'review' && (\n          <div className=\"review-actions\">\n            <button \n              onClick={requestRevision}\n              className=\"action-button request-revision\"\n            >\n              Request Another Revision\n            </button>\n            <button \n              onClick={approveArtwork}\n              className=\"action-button approve\"\n            >\n              Approve Artwork\n            </button>\n          </div>\n        )}\n      </div>\n      \n      <div className=\"workflow-progress\">\n        <div className=\"progress-track\">\n          <div \n            className={`progress-step ${status === 'draft' || status === 'revision' || status === 'review' || status === 'completed' ? 'active' : ''}`}\n          >\n            Draft\n          </div>\n          <div \n            className={`progress-step ${status === 'revision' || status === 'review' || status === 'completed' ? 'active' : ''}`}\n          >\n            Revision\n          </div>\n          <div \n            className={`progress-step ${status === 'review' || status === 'completed' ? 'active' : ''}`}\n          >\n            Review\n          </div>\n          <div \n            className={`progress-step ${status === 'completed' ? 'active' : ''}`}\n          >\n            Completed\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n```",
        "testStrategy": "1. Unit tests for workflow state management:\n   - Test each state transition function\n   - Test that UI updates correctly based on state\n2. Integration tests for the complete workflow:\n   - Test the full lifecycle from draft to completion\n   - Test edge cases like multiple revision cycles\n3. User acceptance testing to verify the workflow matches expected behavior\n4. API endpoint tests for status updates\n5. UI testing to ensure status indicators are clear and intuitive\n6. Accessibility testing for status indicators and buttons\n7. Performance testing to ensure state changes are responsive",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-28T05:21:39.600Z",
      "updated": "2025-08-28T05:21:39.600Z",
      "description": "Tasks for master context"
    }
  }
}